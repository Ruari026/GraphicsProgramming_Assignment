#version 430
layout (local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;
 
// Camera Details
uniform vec3 cameraPos;
uniform vec3 cameraForward;

uniform mat4 cameraViewMatrix;
uniform mat4 cameraProjectionMatrix;

// Lighting Details

// Calculations For Distance Functions Sourced From:
// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm
float signedDstToCircle(vec3 point, vec3 center, float radius)
{
	return length(center - point) - radius;
}

float signedDistToBox(vec3 point, vec3 center, vec3 dimentions)
{
  vec3 q = abs(point - center) - dimentions;
  return length(max(q, 0.0)) + min(max(q.x,max(q.y,q.z)), 0.0);
}

float getDistance(vec3 vector)
{
	return sqrt((vector.x * vector.x) + (vector.y * vector.y) + (vector.z * vector.z));
}

void main() 
{
	vec4 pixel = vec4(0.0, 0.0, 0.0, 0.0);

	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	ivec2 dims = imageSize(img_output); 
	vec2 uv = ((pixel_coords / dims) * 2 - 1);

	// Raycast Details
	vec3 rayOrigin = cameraPos;
	vec3 rayDirection = vec3(inverse(cameraProjectionMatrix) * vec4(cameraForward, 1)).xyz;
	rayDirection = vec3(cameraViewMatrix * vec4(rayDirection,0)).xyz;
	rayDirection = normalize(rayDirection);

	// Object To Check For (Test Sphere Details)
	vec3 sphere_c = vec3(0.0, 0.0, 0.0); //Sphere Position
	float sphere_r = 2.0; // Sphere Radius

	// Raycast Calculations
	float rayDist = 0;
	while (rayDist < 1000)
	{
		// Gets The Distance To The Sphere Surface
		vec3 checkPoint = rayOrigin + (rayDirection * rayDist);
		float dist = signedDstToCircle(checkPoint, sphere_c, sphere_r);
		if (dist <= 0)
		{
			pixel = vec4(0.4, 0.4, 1.0, 1.0);
			break;
		}
		else
		{
			rayDist += dist;
		}
	}

	// Writing to the specific pixel in the image based on the current workgroup
	imageStore(img_output, pixel_coords, pixel);
}

