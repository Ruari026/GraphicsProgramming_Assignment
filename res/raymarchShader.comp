#version 430
layout (local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;
 
// Camera Details
uniform vec3 cameraPos;
uniform vec3 cameraForward;

// Lighting Details

// Calculations For Distance Functions Sourced From:
// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm
float CheckSphere(vec3 rayOrigin, vec3 rayDirection, vec3 spherePos, float sphereRadius)
{
	vec3 omc = rayOrigin - spherePos;
	float b = dot(rayDirection, omc);
	float c = dot(omc, omc) - sphereRadius * sphereRadius;

	return b * b - c;
}



void main() 
{
  // get index in global work group i.e x,y position
  ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

  // Getting Image Dimensions
  ivec2 dims = imageSize(img_output); 

  // Raycast Details
  float max_x = 5.0;
  float max_y = 5.0;
  float x = (float(pixel_coords.x * 2 - dims.x) / dims.x);
  float y = (float(pixel_coords.y * 2 - dims.y) / dims.y);
  vec3 ray_o = cameraPos + vec3(x * max_x, y * max_y, 0.0);
  vec3 ray_d = cameraForward;

  // Object To Check For (Test Sphere Details)
  vec3 sphere_c = vec3(0.0, 0.0, 10.0); //Sphere Position
  float sphere_r = 1.0; // Sphere Radius

  // Raycast Calculations
  float bsqmc = CheckSphere(ray_o, ray_d, sphere_c, sphere_r);


  // hit one or both sides
  // base pixel colour for image
  vec4 pixel;
  if (bsqmc >= 0.0) 
  {
	// Setting Base Color
	pixel = vec4(0.4, 0.4, 1.0, 1.0);

	// Handling Lighting
  }
  else
  {
	// No Change
	pixel = vec4(0.0, 0.0, 0.0, 0.0);
  }
  
  // Writing to the specific pixel in the image based on the current workgroup
  imageStore(img_output, pixel_coords, pixel);
}

